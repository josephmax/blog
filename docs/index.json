[{"uri":"/posts/7%E6%9C%885%E6%97%A5%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0","tags":["面试","事件委托","ECMA"],"content":"Joe 按 ： 共事 还是 极其 讲究 气场 相合 ， 祝 自己 好运 。1. null==undefined> 比较 运算  x==y,  其中  x  和  y  是 值 ， 产生  true  或者  false。 这样 的 比较 按 如下 方式 进行 ：>    1.  若  Type(x)  与  Type(y)  相同 ，  则 >        a.  若  Type(x)  为  Undefined，  返回  true。>        b.  若  Type(x)  为  Null，  返回  true。>        c.  若  Type(x)  为  Number，  则 >        &nbsp;&nbsp;\t    i.  若  x  为  NaN，  返回  false。>        &nbsp;&nbsp;\t   ii.  若  y  为  NaN，  返回  false。>        &nbsp;&nbsp;\t  iii.  若  x  与  y  为 相等 数值 ，  返回  true。>        &nbsp;&nbsp;\t   iv.  若  x  为  +0  且  y  为  −0，  返回  true。>        &nbsp;&nbsp;\t    v.  若  x  为  −0  且  y  为  +0，  返回  true。>        &nbsp;&nbsp;  \t   vi.  返回  false。>        d.  若  Type(x)  为  String,  则 当  x  和  y  为 完全相同 的 字符 序列 （ 长度 相等 且 相同 字符 在 相同 位置 ） 时 返回  true。  否则 ，  返回  false。>        e.  若  Type(x)  为  Boolean,  当  x  和  y  为 同 为  true  或者 同 为  false  时 返回  true。  否则 ，  返回  false。>        f.  当  x  和  y  为 引用 同一 对象 时 返回  true。 否则 ， 返回  false。>    2.  若  x  为  null  且  y  为  undefined，  返回  true。>    3.  若  x  为  undefined  且  y  为  null，  返回  true。>    4.  若  Type(x)  为  Number  且  Type(y)  为  String， 返回 比较  x == ToNumber(y)  的 结果 。>    5.  若  Type(x)  为  String  且  Type(y)  为  Number， 返回 比较  ToNumber(x) == y  的 结果 。>    6.  若  Type(x)  为  Boolean，  返回 比较  ToNumber(x) == y  的 结果 。>    7.  若  Type(y)  为  Boolean，  返回 比较  x == ToNumber(y)  的 结果 。>    8.  若  Type(x)  为  String  或  Number， 且  Type(y)  为  Object， 返回 比较  x == ToPrimitive(y)  的 结果 。>    9.  若  Type(x)  为  Object  且  Type(y)  为  String  或  Number，  返回 比较  ToPrimitive(x) == y  的 结果 。>    10.  返回  false。ECMA 规范 官 网 地址 st=>start: Start:>http://www.google.com[blank]e=>end:>http://www.google.comop1=>operation: My Operationsub1=>subroutine: My Subroutinecond=>condition: Yesor No?:>http://www.google.comio=>inputoutput: catch something...st->op1->condcond(yes)->io->econd(no)->sub1(right)->op12.  事件 委托 技术 3.  如何 深度 克隆 一个 元素 4. ECMAScript6 新增 了 哪些 特性 和 改动 5.  最后 送 上 烧 脑 实例 一枚 ：","title":"7 月 5 日 面试 笔记 ","oriTitle":"7月5日面试笔记"},{"uri":"/posts/hugo-guidance","tags":["hugo","blog generator"],"content":"boiler 作者 留 的 参考 \b， 没舍得 删 \bHugo 是 spf13 大神 写 的 一个 静态 博客 生成器 ， 拥有 仅次于 Hexo 的 用户量 。 相比 于 Hexo，Hugo 使用 Go 编写 ， 生成 速度 快 了 很多 。 除此之外 ，Hugo 的 设计 更加 合理 ， 文档 也 比较 详尽 ， 比较 适合 我 这种 喜欢 从零开始 折腾 的 技术 宅 。 本 博客 就是 在 hugo 上 搭建 的 ， 使用 了 自己 编写 的 主题 ： canoe 。 迁徙 博文 因为 我 以前 使用 的 hexo， 已经 拥有 相当 一部分 博文 了 ， 所以 我 需要 将 原来 hexo 格式 的 博文 转换 到 hugo 中 。 其中 主要 的 差异 在于 front matter，hexo 使用 YAML 格式 ， 这 也 是 支持 最为 广泛 的 格式 。hugo 则 默认 是 toml， 但是 同时 可以 支持 yaml 和 json 格式 。 个人感觉 toml 格式 并 没有 多 大 的 方便 ， 倒 是 YAML 格式 支持 的 最为 广泛 ， 所以 我 还是 在 hugo 中 指定 了 使用 YAML 格式 的 front matter:metaDataFormat = \"yaml\" 但是 仅仅 这样 ， 还是 不能 直接 copy & paste， 因为 hexo 的 front matter 中 date 没有 包含 时 区 信息 而 hugo 则 需要 指定 。 直接 一篇 一篇 的 改 太 过 繁琐 ， 因此 我 写 了 一个 小 工具 来 做 这件 事 ，PS： 需要 先 安装 依赖  mkdirp、moment-timezone 和 gray-matter 。const fs = require(\"fs\");const { promisify } = require(\"util\");const moment = require(\"moment-timezone\");const matter = require(\"gray-matter\");const mkdirp = require(\"mkdirp-promise\");const timezone = \"Asia/Shanghai\";const src = \"hexo\";const target = \"hugo\";const readdir = promisify(fs.readdir);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);const log = console.log.bind(console);const indent = \"   \";function read(name) {  const path = ${src}/${name};  const opts = { encoding: \"utf8\" };  return readFile(path, opts).then(text => ({ name, text }));}function write(file) {  const path = ${target}/${file.name};  return mkdirp(target).then(_ => writeFile(path, file.text));}function check(file) {  file.text = file.text.trim();  if (!/^-{3}\\s*\\n/.test(file.text)) {    file.text = ---\\n${file.text};  }  if (!matter.test(file.text)) {    log(\"Ops,something wrong in file:\", file.name);    return false;  }  return true;}function convert(file) {  log(\"Starting to convert file\", file.name);  const { data, content } = matter(file.text);  // title  if (!data.title)    data.title = file.name      .replace(/\\.md$/, \"\")      .replace(/-/g, \" \")      .replace(/\\b[a-z]/g, m => m.toUpperCase());  log(indent, \"[title]\", data.title);  // date  data.date = moment    .tz(data.date ? new Date(data.date) : new Date(), timezone)    .format();  log(indent, \"[date]\", data.date);  // categories  if (data.categories) {    if (!Array.isArray(data.categories)) {      data.categories = [data.categories];    }    log(indent, \"[categories]\", data.categories);  }  //tags  if (data.tags) {    if (!Array.isArray(data.tags)) data.tags = [data.tags];    log(indent, \"[tags]\", data.tags);  }  file.text = matter.stringify(content, data);  log(\"Done\\n\");  return file;}function main() {  readdir(src)    .then(names => names.filter(name => /\\.md$/.test(name)))    .then(names => Promise.all(names.map(read)))    .then(files => files.filter(check))    .then(files => files.map(convert))    .then(files => Promise.all(files.map(write)))    .then(files => log(Converted ${files.length} files))    .catch(console.error);}main(); 主题 hugo 的 主题 大部分 都 是 非常 简陋 的 ， 看得出来 都 是 一群 后 端 程序员  😂， 看 了 一圈 没有 我 喜欢 的 ， 加上 自己 对 博客 主题 设计 有 一些 自己 的 想法 ， 于是 就 自己 动手 写 了 当前 这个 主题 。 取名 叫 canoe 吧 ， 有 特殊 的 纪念 意义 。 模版 类型 hugo 把 一个 博客 的 模版 归 总成 了 四大 类 ： index ,single,list,terms 分别 代表 首页 模版 、 详情 （ 文章 ） 页 模版 、 列表 页 模版 和 分类 页 模版 （categories、tags）。 而且 hugo 还 能 为 页面 定义 不同 的 类型 (type)， 不同 的 类型 可以 编写 不同 的 模版 ， 也 可以 fallback 到 默认 的 模版 ( 如 对于 类型 是 archive 的 文章 ， 首先 采用 的 是 archive\\signle.html  如果 前者 找 不到 则 会 采用 默认 的 文章 模版 _default\\single.html)。 文章 分类 文章 分类 在 hugo 中 是 一个 比较 抽象 的 概念 ， 统称 为 taxonomies， 是 一个 key-array 的 结构 ， 包括 categories 和 tags。 我们 可以 实现 terms.html 来 展示 某 一类 taxonomy 所 包含 的 文章 列表 。 前端开发 hugo 默认 只 提供 了 一个 高性能 的 livereload 服务器 。 但是 开发 主题 需要 用到 很多 前端 相关 的 流程 ， 包括 热 替换 、 前端 资源 预处理 和 后处理 等 等等 ， 所以 我 还是 引入 了 gulp 。 使用 了 一套 我 最 熟悉 的 技术 组合 ： 使用 typescript 和 rollup 来 编写 脚本 使用 sass  和 postcss 来 编写 样式 使用 browserSync 来 进行 热 替换 与 hugo 相关 的 gulp 任务 ：gulp.task(\"hugo\", cb => {  const prodArgs = [\"-d\", ./${devDir}];  const devArgs = [\"-d\", ./${devDir}, \"-w\", \"-b\", \"/.\"];  const hugo = cp.spawn(\"hugo\", env === \"dev\" ? devArgs : prodArgs);  hugo.stdout.on(\"data\", data => util.log(data.toString()));  hugo.stderr.on(\"data\", data => util.log(\"error: \", data.toString()));  hugo.on(\"exit\", code => {    util.log(\"hugo process exited with code\", code);    env !== \"dev\" && cb();  });  // env == dev is in watch mode  env === \"dev\" && cb();}); 延迟 加载 Valinewindow[\"VALINECONFIG\"] = {  el: '#comment',  notify: false,  verify: false,  appId: '{{ .valine.id }}',  appKey: '{{ .valine.key }}',  placeholder: '{{ .valine.placeholder }}',  path: window.location.pathname,  avatar: '{{ .valine.avatar }}'}function loadValine() {  const config = window[\"VALINECONFIG\"];  if (!config) return;  const urls = [${baseURL}/js/av-min.js, ${baseURL}/js/Valine.min.js];  const asyncloader = url =>    new Promise((resolve, reject) => {      const script = document.createElement(\"script\");      script.src = url;      script.addEventListener(\"load\", _ => resolve(), false);      script.addEventListener(\"error\", _ => reject(), false);      document.body.appendChild(script);    });  Promise.all(urls.map(asyncloader))    .then(() => new window\"Valine\")    .catch(e => U.log(\"load Valine Failed,\", e));} 搜索 hugo 在 官方 文档   提到 了 几种 实现 站点 搜索 的 方式 。 抛开 第三方 搜索 工具 不论 只 剩下 lunr 了 。 但是 lunr 需要 一个 索引 文件 ，hugo 没有 像 hexo 那样 的 hexo-generate-json-content 插件 （ 其实 它 压根 就 没有 插件 系统 ） 所以 到 最后 还是 用 Node 来 干 这件 事情 吧 ， 而且 刚好 我 已经 搭 好 了 一个 可用 的 gulp workflow 了 。 需要 注意 的 是 lunr 默认 不 支持 中文搜索 。 这 是 一个 非常 蛋 疼 问题 ， 网上 的 解决 方法 通常 是 这样 的 ：const trimmer = function(token) {  return token.update(str => {    if (/[\\u4E00-\\u9FA5\\uF900-\\uFA2D]/.test(str)) return str;    return str.replace(/^\\W+/, \"\").replace(/\\W+$/, \"\");  });};const lunr_zh = function() {  this.pipeline.reset();  this.pipeline.add(trimmer, lunr.stopWordFilter, lunr.stemmer);};lunr.Pipeline.registerFunction(trimmer, \"trimmer-zh\");//...const index = lunr(function() {  this.use(lunr_zh);  //...}); 这里 通过 注册 一个 自定义 的 trimmer  方法 来 避免 中文 字符 被 忽略 ， 分词 算法 应该 写 到 stemmer 函数 中 ， 但是 中文 分词 算法 并 不是 那么 几行 代码 就 能 搞定 的 ， 如果 全部 放到 线 上 的话 ， 会 极大 的 拖 慢 浏览器 的 加载 速度 。 因此 我们 只能 直接 沿用 原有 的 分词 算法 lunr.stemmer  在 本地 就 把 中文 分词 分 好 用 空格 分开 ， 这样 线 上 就 可 略 过分 词 这 一个 步骤 了 。 我 写 了 一个 工具 来 做 这个 ， 使用 了 nodejieba 库 ， 分词 速度 挺快 的 。 主要 逻辑 是 ：const matter = require(\"gray-matter\");const removeMd = require(\"remove-markdown\");const nodejieba = require(\"nodejieba\");// ...function parse(filename, option) {  const filepath = path.join(option.dir, filename);  const { name } = path.parse(filepath);  let { data:meta, content } = matter.read(filepath);  return {    uri:      path.join(option.contextPath, urlize(name)),    tags:     meta.tags || [],    content:  ChineseCut(removeMd(content)),    title:    ChineseCut(meta.title),    oriTitle: meta.title  };}function ChineseCut(str) {  return (    str &&    str      .replace(/\\n/gm, \"\")      .replace(        /[\\u4E00-\\u9FA5\\uF900-\\uFA2D]+/g,        match =>  ${nodejieba.cut(match).join(\" \")}       )  );} 主要 是 利用 gray-matter 这个 库 对 文档 内容 进行 解析 ， 然后 把 得到 的 content 和 title 字 段 使用 ChineseCut 方法 进行 分词 ， 将 分词 后 的 数组 重新 使用 空格 拼接 成 字符串 返回 ， 最后 得到 一个 文章 描述 对象 ， 包含 着 uri、tags、content、title 和 oriTitle  这 几个 字 段 。 动画 动画 绝大 情况 可以 使用 css3 transition 解决 ， 但是 还是 有 一些 css 无能为力 的 情况 。 比如说 章节 滚动 等 。 因此 我 用 requestAnimate 写 了 一个 简单 的 纯 动画 方法 ：class Animate {  private id = 0;  private active = {};  constructor() {}  private uniqKey() {    return ++this.id;  }  exec(    transform: Function,    duration: number,    easingFn: Function = linear,    cb?: Function  ) {    const key = this.uniqKey();    this.active[key] = true;    const start = performance.now();    const render = (now = performance.now()) => {      const delta = now - start;      if (!this.active[key] || delta >= duration) {        transform(1);        delete this.active[key];        cb && cb();        return;      }      transform(easingFn(delta / duration));      requestAnimationFrame(render);    };    requestAnimationFrame(render);  }  cancel(key: number) {    if (this.active[key] === true) {      this.active[key] = false;    }  }}//examplelet id = null;const animate = new Animate();// ... other animationconst el = document.querySelector('modal');const easeOutCubic = t => --t * t * t + 1;const transition = p => (el.style.opacity = ${p}),if(id) animate.cancel(id);id = animate.exec(transition, 200, easeOutCubic); 更 多 的 动画 函数 可以 参考 ： 部署 Github Pageshugo 官方 教程 是 通过 添加 一个 orphan 的 gh-pages 分支 ， 然后 使用 git worktree 特性 来 将 master 分支 里面 的 public 目录 定位 到 gh-pages 中 的 。 整个 过程 比较复杂 ， 部署 的 过程 中 需要 切换 工作 目录 。 所以 官方 也 提供 了 一个 shell 脚本 来 自动 干 这 事 。 我 这边 直接 使用 了 github 的 docs 文件夹 特性 。 在 config.toml 中 添加 一行 publishDir: docs 将 站点 文件 生成 至 docs 文件夹 下 ， 然后 直接 在 master 分支 中 开启 github page 就 好 了 。github 会 自动 部署 docs 文件夹 里面 的 静态 文件 。 绑定 域名 和 HTTPSGithub 绑定 域名 就 不 说 了 ， 主要 添加 两条 A 记录 ， 然后 在 Github 上 设置 一下 即可 。 但是 Github 绑定 域名 之后 无法 再 使用 https 了 （coding.net 说 起来 这点 还 挺 良心 的 ）， 目前 免费 的 解决方案 只能 使用 cloudflare 这种 cdn 了 。Netlify 使用 Github Pages 的 方式 主要 不足 是 每次 提交 站点 源码 之前 需要 自己 手动 在 本地 先 build 一下 ， 另外 使用 master/docs 的 方式 的话 还 会 污染 每次 的 提交 信息 。Netlify 是 一个 不错 的 选择 ， 连接 了 Github 之后 可以 像 TravisCL 那样 ， 持续 集成 部署 了 。 另一方面 ，Netlify 不仅 能够 绑定 域名 ， 提供 https 访问 ， 还 能 支持 HTTP/2 协议 ， 完全免费 ， 国内 速度 也 不错 。 官方网站 Forestry 这个 挺 强大 的 ， 像是 把 静态 博客 变成 了 一个 动态 博客 。 但是 环境 不能自己 配置 ， 不 太 适合 我 。 官方网站 ","title":"Hugo 使用 笔记 ","oriTitle":"Hugo使用笔记"},{"uri":"/posts/my-first-post","tags":["心得","随想","demo"],"content":" 我 的 第一篇 博客 第一篇 用 markdown 语法 码 出来 的 博客 什么 是  MarkdownMarkdown  是 一种 方便 记忆 、 书写 的 纯 文本 标记 语言 ， 用户 可以 使用 这些 标记符号 以 最小 的 输入 代价 生成 极富 表现力 的 文档 ： 譬如 您 正在 阅读 的 这份 文档 。 它 使用 简单 的 符号 标记 不同 的 标题 ， 分割 不同 的 段落 ， 粗体   或者   斜体   某些 文字 ， 更 棒 的 是 ， 它 还 可以 1.  制作 一份 待办 事宜  Todo  列表 [ ]  支持 以  PDF  格式 导出 文稿 [ ]  改进  Cmd  渲染 算法 ， 使用 局部 渲染 技术 提高 渲染 效率 [x]  新增  Todo  列表 功能 [x]  修复  LaTex  公式 渲染 问题 [x]  新增  LaTex  公式 编号 功能 2.  书写 一个 质 能 守恒 公式 $$E=mc^2$$3.  高 亮 一段 代码 `python@requires_authorizationclass SomeClass:    passif name == 'main':A comment    print 'hello world'`4.  高效 绘制   流程图 `flowst=>start: Startop=>operation: Your Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op`5.  高效 绘制   序列图 `seqAlice->Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob-->Alice: I am good thanks!`6.  绘制 表格 |  项目         |  价格    |   数量   || --------   | -----:  | :----:  ||  计算机      | \\$1600 |   5     ||  手机         |   \\$12   |   12   ||  管线         |    \\$1    |  234  |7.  更 详细 语法 说明 想要 查看 更 详细 的 语法 说明 ， 可以 参考 我们 准备 的  Cmd Markdown  简明 语法 手册 ， 进阶 用户 可以 参考  Cmd Markdown  高阶 语法 手册   了解 更 多 高级 功能 。 总而言之 ， 不同于 其它   所见即 所得   的 编辑器 ： 你 只 需 使用 键盘 专注 于 书写 文本 内容 ， 就 可以 生成 印刷 级 的 排版 格式 ， 省却 在 键盘 和 工具栏 之间 来回 切换 ， 调整 内容 和 格式 的 麻烦 。Markdown  在 流畅 的 书写 和 印刷 级 的 阅读 体验 之间 找到 了 平衡 。  目前 它 已经 成为 世界 上 最大 的 技术 分享 网站  GitHub  和   技术 问答 网站  StackOverFlow  的 御用 书写 格式 。 什么 是  Cmd Markdown 您 可以 使用 很多 工具 书写  Markdown， 但是  Cmd Markdown  是 这个 星球 上 我们 已知 的 、 最好 的  Markdown  工具 —— 没有 之一  ：） 因为 深信 文字 的 力量 ， 所以 我们 和 你 一样 ， 对 流畅 书写 ， 分享 思想 和 知识 ， 以及 阅读 体验 有 极致 的 追求 ， 我们 把 对于 这些 诉求 的 回应 整合 在  Cmd Markdown， 并且 一次 ， 两次 ， 三次 ， 乃至 无数次 地 提升 这个 工具 的 体验 ， 最终 将 它 演化成 一个   编辑 / 发布 / 阅读  Markdown  的 在线 平台 —— 您 可以 在 任何 地方 ， 任何 系统 / 设备 上 管理 这里 的 文字 。1.  实时 同步 预览 我们 将  Cmd Markdown  的 主 界面 一分为二 ， 左边 为 编辑 区 ， 右边 为 预览 区 ， 在 编辑 区 的 操作 会 实时 地 渲染 到 预览 区 方便 查看 最终 的 版面 效果 ， 并且 如果 你 在 其中 一个 区 拖动 滚动条 ， 我们 有 一个 巧妙 的 算法 把 另 一个 区 的 滚动条 同步 到 等价 的 位置 ， 超酷 ！2.  编辑 工具栏 也许 您 还是 一个  Markdown  语法 的 新手 ， 在 您 完全 熟悉 它 之前 ， 我们 在   编辑 区   的 顶部 放置 了 一个 如下 图 所示 的 工具栏 ， 您 可以 使用 鼠标 在 工具栏 上 调整 格式 ， 不过 我们 仍旧 鼓励 你 使用 键盘 标记 格式 ， 提高 书写 的 流畅 度 。3.  编辑 模式 完全 心无旁骛 的 方式 编辑 文字 ： 点击   编辑 工具栏   最 右 测 的 拉伸 按钮 或者 按 下  Ctrl + M， 将  Cmd Markdown  切换 到 独立 的 编辑 模式 ， 这 是 一个 极度 简洁 的 写作 环境 ， 所有 可能 会 引起 分心 的 元素 都 已经 被 挪 除 ， 超 清爽 ！4.  实时 的 云端 文稿 为了 保障 数据安全 ，Cmd Markdown  会 将 您 每 一次 击键 的 内容 保存 至 云端 ， 同时 在   编辑 工具栏   的 最 右侧 提示   已 保存   的 字样 。 无需 担心 浏览器 崩溃 ， 机器 掉电 或者 地震 ， 海啸 —— 在 编辑 的 过程 中 随时 关闭 浏览器 或者 机器 ， 下 一次 回到  Cmd Markdown  的 时候 继续 写作 。5.  离线 模式 在 网络 环境 不 稳定 的 情况 下 记录 文字 一样 很 安全 ！ 在 您 写作 的 时候 ， 如果 电脑 突然 失去 网络连接 ，Cmd Markdown  会 智能 切换 至 离线 模式 ， 将 您 后续 键入 的 文字 保存 在 本地 ， 直到 网络 恢复 再 将 他们 传送 至 云端 ， 即使 在 网络 恢复 前 关闭 浏览器 或者 电脑 ， 一样 没有 问题 ， 等到 下次 开启  Cmd Markdown  的 时候 ， 她 会 提醒您 将 离线 保存 的 文字 传送 至 云端 。 简而言之 ， 我们 尽 最大 的 努力 保障 您 文字 的 安全 。6.  管理 工具栏 为了 便于管理 您 的 文稿 ， 在   预览 区   的 顶部 放置 了 如下 所示 的   管理 工具栏 ： 通过 管理 工具栏 可以 ：  发布 ： 将 当前 的 文稿 生成 固定 链接 ， 在 网络 上 发布 ， 分享   新建 ： 开始 撰写 一篇 新 的 文稿   删除 ： 删除 当前 的 文稿   导出 ： 将 当前 的 文稿 转化 为  Markdown  文本 或者  Html  格式 ， 并 导出 到 本地   列表 ： 所有 新增 和 过往 的 文稿 都 可以 在 这里 查看 、 操作   模式 ： 切换   普通 /Vim/Emacs  编辑 模式 7.  阅读 工具栏 通过   预览 区   右上角 的   阅读 工具栏 ， 可以 查看 当前 文稿 的 目录 并 增强 阅读 体验 。 工具栏 上 的 五个 图标 依次 为 ：  目录 ： 快速 导航 当前 文稿 的 目录 结构 以 跳转 到 感兴趣 的 段落   视图 ： 互换 左边 编辑 区 和 右边 预览 区 的 位置   主题 ： 内置 了 黑白 两种 模式 的 主题 ， 试试   黑色 主题 ， 超 炫 ！  阅读 ： 心无旁骛 的 阅读 模式 提供 超一流 的 阅读 体验   全屏 ： 简洁 ， 简洁 ， 再 简洁 ， 一个 完全 沉浸 式 的 写作 和 阅读 环境 8.  阅读 模式 在   阅读 工具栏   点击    或者 按 下  Ctrl+Alt+M  随即 进入 独立 的 阅读 模式 界面 ， 我们 在 版面 渲染 上 的 每 一个 细节 ： 字体 ， 字号 ， 行间距 ， 前 背景色 都 倾注 了 大量 的 时间 ， 努力 提升 阅读 的 体验 和 品质 。9.  标签 、 分类 和 搜索 在 编辑 区 任意 行 首 位置 输入 以下 格式 的 文字 可以 标签 当前 文档 ： 标签 ：  未分类 标签 以后 的 文稿 在 【 文件 列表 】（Ctrl+Alt+F） 里 会 按照 标签 分类 ， 用户 可以 同时 使用 键盘 或者 鼠标 浏览 查看 ， 或者 在 【 文件 列表 】 的 搜索 文本框 内 搜索 标题 关键字 过滤 文稿 ， 如下 图 所示 ：10.  文稿 发布 和 分享 在 您 使用  Cmd Markdown  记录 ， 创作 ， 整理 ， 阅读 文稿 的 同时 ， 我们 不仅 希望 它 是 一个 有力 的 工具 ， 更 希望 您 的 思想 和 知识 通过 这个 平台 ， 连同 优质 的 阅读 体验 ， 将 他们 分享 给 有 相同 志趣 的 人 ， 进而 鼓励 更 多 的 人 来到 这里 记录 分享 他们 的 思想 和 知识 ， 尝试 点击   (Ctrl+Alt+P)  发布 这份 文档 给 好友 吧 ！","title":"my first post","oriTitle":"my first post"},{"uri":"/posts/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88","tags":["面试","跨域","Ajax"],"content":" 跨 域 请求 数据 解决方案 主要 有 如下 解决 方法 ：JSONP 方式 表单 POST 方式 服务器 代理 Html5 的 XDomainRequestFlash requestJoe 按 ： 今天 太 累 ， 未 加 整理 ， 先 贴 链接 供 查看 ， 稍作 休息 再 编辑 消化 。 链接 地址 ","title":" 前端 跨 域 问题 解决方案 ","oriTitle":"前端跨域问题解决方案"},{"uri":"/posts/%E7%94%B1%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BB%B6%E4%BC%B8%E5%BC%80%E5%8E%BB%E7%9A%84%E5%92%80%E5%9A%BC%E7%89%A9","tags":["掉书袋","计算机基础(伪)","算法","javascript"],"content":"Joe 按 ： 其实 是 写 来 补 一 补 作为 一个 前端 渣 的 计算机 基础 的 ， 读 了 四个 月 的 html，css，js， 愈发 觉得 基础 上 的 薄弱 。 故 夜深人静 的 时候 研究 了 以下 几个 问题 。 钻研 深度 有限 ， 大神 勿 见笑 ， 如 有 新 的 体会 日后 会 来 更新 。 如何 用 js 实现 快速 排序 ？> 引用 阮 一峰 大神 的 日志 : 快速 排序 （Quicksort） 的 Javascript 实现 。 里面 的 图解 讲 得 十分 清楚 。 摘要 一下 ， 核心思想 就是 ：\t 在 数据 集 之中 ， 选择 一个 元素 作为 \" 基准 \"（pivot）。　　 所有 小于 \" 基准 \" 的 元素 ， 都 移 到 \" 基准 \" 的 左边 ； 所有 大于 \" 基准 \" 的 元素 ， 都 移 到 \" 基准 \" 的 右边 。　　 对 \" 基准 \" 左边 和 右边 的 两个 子集 ， 不断 重复 第一步 和 第二步 ， 直到 所有 子集 只 剩下 一个 元素 为止 。 作为 初学者 友好 向 的 读物 ， 我 给 这 段 算法 写 了 注释 。>var quickSort = function(arr) {　　if (arr.length 那么 ， 究竟 比 冒泡 快 多少 呢 ？ 点击 这里 可以 看到 ， 这 是 日本 程序员 norahiko 做 的 很 有意思 的 排序 算法 动画 演示 。 我 简单 试验 了 一下 将 条目 数 设 为 150 条 ， 运算 速度 调 为 最快 的 时候 ， 冒泡排序 花 了 近 50 秒 ， 而 快速 排序 只 花 了 5 秒 不到 。 高下 立 判 。 如何 用 js 实现 二分 查找 ？>// 二分 搜索 //A 为 已 按 \" 升序 排列 \" 的 数组 ，x 为 要 查询 的 元素 // 返回 目标 元素 的 下标 function binarySearch(A, x) {  var low = 0, high = A.length - 1;  while (low 实例 ： 如何 装 一个 有 深度 的 比 ？ 一个 简单 的 函数 见分晓 。Amazon 面试题 实例 ：swap two integers without temp （ 写 一个 函数 ， 交换 两个 整数 ,  不能 用 任何 临时 变量 ） 一般 人 会 写出 这样 的 方法 ：>function swapNumb(a, b){  console.log('before swap: ','a: ', a, 'b: ', b);  b = b - a;  a = a + b;  b = a - b;  console.log('after swap: ','a: ', a, 'b: ', b);} 余 看 了 之后 大 受 启发 ， 写 了 个 ：>function swapNumb(a, b){  console.log('before swap: ','a: ', a, 'b: ', b);  a = a + b;  b = a - b;  a = a - b;  console.log('after swap: ','a: ', a, 'b: ', b);} 然而 成就感 还 未 出生 便 被 高手 的 装 逼 之 术 扼杀 在 摇篮 里 了 ， 据说 面试官 真正 喜欢 的 写法 是 如下 这个 ：>function swapNumb(a, b){  console.log(\"a: \" + a + \" and b: \" + b);  a = a ^ b;  b = a ^ b;  a = a ^ b;  console.log(\"a: \" + a + \" and b: \" + b);} 装 逼 方法 提供者 ：haochuan 链接 ：http://www.zhihu.com/question/28860309/answer/42522021 来源 ： 知 乎 何为 ^? 异或 运算 是 也 ，xor。 在 计算机 中 普遍 运用 ， 异或 的 逻辑 符号  ^ (Shift + 6) 或 一个 圆圈 里面 增加 一个 + 或者 ·. 形象 表示 为 ：   真 ^ 假 = 真    假 ^ 真 = 真    假 ^ 假 = 假    真 ^ 真 = 假如 2^3=1;  2^1=3;  1^3=2; 通俗 的 解释 如下 ：    与 运算 （AND）：0 AND 0 = 0  （ 全 为 1 才 得 1）                    1 AND 0 = 0                    0 AND 1 = 0                    1 AND 1 = 1    或 运算 （OR）：0 OR 0 = 0  （ 只要 有 一个 1 就 得 1）                    1 OR 0 = 1                    0 OR 1 = 1                    1 OR 1 = 1    取反 运算 （NOT）: NOT 1 = 0                        NOT 0 = 1    异或 运算 （XOR）：0 XOR 0 = 0  ( 不同 为 1， 相同 为 0)                        1 XOR 0 = 1                        0 XOR 1 = 1                        1 XOR 1 = 0   > 附 ： 异或 的 特殊性 ：   > 若  A XOR B = C, 则  A XOR C = B,B XOR C = A.   > 扩展 成  A XOR B XOR C = D, 结论 同样 成立 高下 立 判 。 二 、 十 、 十六进制 转换 的 算法 依据 二进制 与 十进制 数间 的 转换 \t 二进制 转换 为 十进制 将 每个 二进制 数 按 权 展开 后 求和 即可 。 请 看 例题 ： 把 二进制 数 （101.101）2=122+021+120+12-1+02-2+12-3=（5.625）10\t 十进制 转换 为 二进制 一般 需要 将 十进制 数 的 整数 部分 与 小数 部分 分开 处理 。 整数 部分 计算方法 ： 除 2 取 余 法   请 看 例题 ： 十进制 数 （53）10 的 二进制 值 为 （110101）2 小数 部分 计算方法 ： 乘 2 取 整 法 ， 即 每 一步 将 十进制 小数 部分 乘以 2， 所得 积 的 小数点 左边 的 数字 （0 或 1） 作为 二进制 表示法 中 的 数字 ， 第一次 乘法 所得 的 整数 部分 为 最高 位 。 请 看 例题 ： 将 （0.5125）10 转换成 二进制 。（0.5125）10=（0.101）2 二进制 与 十六进制 转换 转换方法 ： 以 小数点 为 界 ， 分别 向 左右 每 四位 二进制 合成 一位 十六进制 数 ， 或 每 一位 十六进制 数 展 成 四位 二进制 数 ， 不足 四位 者 补 0。 例如 ：（ABCD。EF）16=（1010 1011 1100 1101.1110 1111）2（101101101001011.01101）2=（0101 1011 0100 1011.0110 1000）2=（5B4B。68）16 简单 写 一个 用 递归 思路 实现 十进制 转换 二进制 的 js 程序 ：>// 将 10 进制 数 转化成 2 进制 function toBin(dec) {  var bits = [];  var dividend = dec;  var remainder = 0;  while (dividend >= 2) {    remainder = dividend % 2;    bits.push(remainder);    dividend = (dividend - remainder) / 2;  }  bits.push(dividend);  bits.reverse();  return bits.join(\"\");}// 计算 x 的 m 次 幂 （ 非 递归 实现 ）// 很 独特 的 一种 解法 function exp(x, m) {  var y = 1;  var bin = toBin(m).split('');  // 先 将 m 转化成 2 进制 形式   for (var j = 0; j `","title":" 由 面试题 延伸 开去 的 咀嚼 物 ","oriTitle":"由面试题延伸开去的咀嚼物"}]